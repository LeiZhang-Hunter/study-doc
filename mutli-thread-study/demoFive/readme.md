#为什么要使用bind

在传统的 C++ 程序中,事件回调是通过虚函数进行的。网络库往往会定义一个
或几个抽象基类(Handler class),其中声明了一些(纯)虚函数,如 onConnect()、
onDisconnect()、onMessage()、onTimer() 等等。使用者需要继承这些基类,并覆写
(override)这些虚函数,以获得事件回调通知。由于 C++ 的动态绑定只能通过指针
和引用实现,使用者必须把派生类(MyHandler)对象的指针或引用隐式转换为基类
(Handler)的指针或引用,再注册到网络库中。MyHandler 对象通常是动态创建的,
位于堆上,用完后需要 delete。网络库调用基类的虚函数,通过动态绑定机制实际调
用的是用户在派生类中 override 的虚函数,这也是各种 OO framework 的通行做法。
这种方式在 Java 这种纯面向对象语言中是正当做法 16 。但是在 C++ 这种非 GC 语言
中,使用虚函数作为事件回调接口有其本质困难,即如何管理派生类对象的生命期。
在这种接口风格中,MyHandler 对象的所有权和生命期很模糊,到底谁(用户还是网
络库)有权力释放它呢?有的网络库甚至出现了 delete this; 这种代码,让人捏一
把汗:如何才能保证此刻程序的其他地方没有保存着这个即将销毁的对象的指针呢?
另外,如果网络库需要自己创建 MyHandler 对象(比方说需要为每个 TCP 连接创建
一个 MyHandler 对象),那么就得定义另外一个抽象基类 HandlerFactory,用户要从
它派生出 MyHandlerFactory,再把后者的指针或引用注册到网络库中。以上这些都
是面向对象编程的常规思路,或许大家已经习以为常。
在现代 C++ 中 (指 2005 年 TR1 之后, 不是最新的 C++11), 事件回调有了
新 的 推 荐 做 法, 即 boost::function + boost::bind (即 std::tr1::function +
std::tr1::bind,也是最新 C++11 中的 std::function + std::bind),这种方式的
一个明显优点是不必担心对象的生存期。muduo 正是用 boost::function 来表示事
件回调的,包括 TCP 网络编程的三个半 IO 事件和定时器事件等。用户代码可以传入
签名相同的全局函数,也可以借助 boost::bind 把对象的成员函数传给网络库作为事
件回调的接受方。这种接口方式对用户代码的 class 类型没有限制(不必从特定的基
类派生),对成员函数名也没有限制,只对函数签名有部分限制。这样自然也解决了
空悬指针的难题,因为传给网络库的都是具有值语义的 boost::function 对象。从这
个意义上说,muduo 不是一个面向对象的库,而是一个基于对象的库。因为 muduo
暴露的接口都是一个个的具体类,完全没有虚函数(无论是调用还是回调)。
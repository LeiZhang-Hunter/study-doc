#关于锁

####四大设计原则

1.尽量最低限度的使用共享对象，减少需要同步的场合。一个对象能不暴露给别的线程就不要暴露；如果要暴露，有限考虑immutable对象；实在不行才可以暴露要修改的对象；实在不行可以修改暴露的对象，并且用同步措施来保护他。

2.其次是使用高级的并发编程构件，如TaskQueue,Producer-Consumer Queue,Count DownLatch;

3.最后不得已必须要使用同步原语的时候，只用互斥器和条件变量，慎用读写锁，不用信号量。

4.不要自己编写lock free代码，也不要使用内核级的同步原语。


####2.1互斥器

互斥器是使用最多的同步原语。单独使用mutex的时候主要是为了使用共享数据。我的个人原则是：

使用RAII的手法创建销毁加锁解锁，这四个操作。避免因为忘记

只是使用非递归的mutex。

不手工调用Lock和unlock函数，一切交给栈上的Guard 对象的构造和析构函数负责。Guard的生命周期正好等于临界区。这样我们可以保证在同一个scope里，自动的加解锁。

在每次构造Guard对象的时候，思考一路上已经持有的锁,防止因加锁不同造成的死锁

次要原则是：

不使用非递归的mutex

加锁和解锁要在同一个线程，线程a不能去unlock线程b已经锁住的mutex

别忘了解锁

不重复解锁

必要的时候使用PTHREAD_MUTEX_ERRORCHECK来排错

####2.1.1只使用非递归的mutex


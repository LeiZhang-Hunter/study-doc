#关于锁

####四大设计原则

1.尽量最低限度的使用共享对象，减少需要同步的场合。一个对象能不暴露给别的线程就不要暴露；如果要暴露，有限考虑immutable对象；实在不行才可以暴露要修改的对象；实在不行可以修改暴露的对象，并且用同步措施来保护他。

2.其次是使用高级的并发编程构件，如TaskQueue,Producer-Consumer Queue,Count DownLatch;

3.最后不得已必须要使用同步原语的时候，只用互斥器和条件变量，慎用读写锁，不用信号量。

4.不要自己编写lock free代码，也不要使用内核级的同步原语。


####2.1互斥器

互斥器是使用最多的同步原语。单独使用mutex的时候主要是为了使用共享数据。我的个人原则是：

使用RAII的手法创建销毁加锁解锁，这四个操作。避免因为忘记

只是使用非递归的mutex。

不手工调用Lock和unlock函数，一切交给栈上的Guard 对象的构造和析构函数负责。Guard的生命周期正好等于临界区。这样我们可以保证在同一个scope里，自动的加解锁。

在每次构造Guard对象的时候，思考一路上已经持有的锁,防止因加锁不同造成的死锁

次要原则是：

不使用非递归的mutex

1)加锁和解锁要在同一个线程，线程a不能去unlock线程b已经锁住的mutex

2)别忘了解锁

3)不重复解锁

4)必要的时候使用PTHREAD_MUTEX_ERRORCHECK来排错

####2.1.1只使用非递归的mutex

谈谈我坚持使用非递归的互斥器个人想法

mutex分为递归和非递归两种，这是posix的叫法，另外的名字是可重入和非可重入两种。这两种区别是同一个线程可以重复对可重入锁加锁，但是不能对非递归来加锁。

首选非递归的mutex，绝对不是为了性能，而是为了体现设计意图。递归和非递归其实性能差距不大，因为少了一个计数器，前者略微快一点，在 同一个线程里
多次使用非递归锁会导致死锁，这是一个优点，可以让我们及早发现不足。

毫无疑问递归锁用起来方便一些，不需要考虑在同一个线程里会自己把自己给锁死。

正是因为他很方便，递归锁可能会隐藏一些问题，你以为拿到一个锁可以修改对象了，没想到外层代码已经拿到了锁，正在修改同一个对象呢。

下面让我们看一下递归锁和非递归锁他们是如何使用的

首先我封装了一个mutex

```
class MutexLock{
public:
    MutexLock()
    {
        pthread_mutexattr_init(&mutexattr);
        pthread_mutex_init(&mutex, nullptr);
    }

    MutexLock(int type)
    {
        int res;
        pthread_mutexattr_init(&mutexattr);
        res = pthread_mutexattr_settype(&mutexattr,type);
        pthread_mutex_init(&mutex, &mutexattr);
    }

    ~MutexLock()
    {
        pthread_mutex_destroy(&mutex);
    }

    void lock()
    {
        int res = pthread_mutex_lock(&mutex);
        std::cout<<res<<std::endl;
    }

    void unLock()
    {
        pthread_mutexattr_destroy(&mutexattr);
        pthread_mutex_unlock(&mutex);
    }
private:
    pthread_mutex_t mutex;
    pthread_mutexattr_t mutexattr;
};
```

在构造函数中传入type来确定锁的类型

然后我们看一段demo

```
MutexLock mutex(PTHREAD_MUTEX_RECURSIVE);


void foo()
{
    mutex.lock();
    // do something
    mutex.unLock();
}

void* func(void* arg)
{
    mutex.lock();
    printf("3333\n");
}

int main()
{
    pthread_t tid;
    pthread_create(&tid, nullptr,func, nullptr);
    foo();
    int res;
    mutex.lock();
    sleep(5);
    mutex.unLock();
    sleep(3);
}
```

这一段代码中我们在主线程里foo 后又mutex.lock之后我们发现程序并没有死锁,而是继续执行，也就是说同一个线程里递归锁是可以重入的并不会造成死锁

我们在来测试一下默认的锁，将申请方式调整为:

```
MutexLock mutex(PTHREAD_MUTEX_DEFAULT);
```

我们会发现上面这段程序死锁了！！

我在这里是十分认同陈硕的说法，用非递归锁的优势是十分明显的，他非常容易发现错误，即使出现了死锁我们使用gdb去对应的线程里bt就可以了

当然我们也可以使用c里面的属性PTHREAD_MUTEX_ERRORCHECK_NP来检查错误，我们只需要如下声明锁

```
MutexLock mutex(PTHREAD_MUTEX_ERRORCHECK_NP);
```

然后我们使用下面的程序

```
int main()
{
    pthread_t tid;
    int res;
    res = mutex.lock();
    printf("%d\n",res);
    res = mutex.lock();
    printf("%d\n",res);
    mutex.unLock();
    printf("end\n");
}
```

这样我们出现死锁的时候，会返回EDEADLK
```
#define	EDEADLK		35	/* Resource deadlock would occur */
```

所以说由于对于出了问题容易排错的角度我对书里面只使用非递归锁的做法比较认可,死锁也就不在阐述了，定位问题的方法也在上面说过了

####2.2条件变量

互斥器是为了防止计算器资源争抢，具有排他的特性，但是如果我们希望等待某个条件成立，然后实现解锁

我们在unix网络环境编程里肯定都学过对应的函数

```
pthread_cond_wait
pthread_cond_signal
```

如果需要等待一个条件成立，我们要使用条件变量.条件变量是多个线程或一个线程等待某个条件成立才被唤醒。条件变量的学名也叫管程！

条件变量只有一种使用方式，几乎不可能用错。对于wait端：

1.必须和mutex一起使用，这个布尔值必须收到mutex保护

2.mutex已经上锁的时候才能调用wait

3。把判断布尔条件和wait放到while循环中

针对上述代码我门来写一个例子： 

我们首先来实现一个条件变量库，我们去看一下muduo之中是怎么实现的


#关于锁

####四大设计原则

1.尽量最低限度的使用共享对象，减少需要同步的场合。一个对象能不暴露给别的线程就不要暴露；如果要暴露，有限考虑immutable对象；实在不行才可以暴露要修改的对象；实在不行可以修改暴露的对象，并且用同步措施来保护他。

2.其次是使用高级的并发编程构件，如TaskQueue,Producer-Consumer Queue,Count DownLatch;

3.最后不得已必须要使用同步原语的时候，只用互斥器和条件变量，慎用读写锁，不用信号量。

4.不要自己编写lock free代码，也不要使用内核级的同步原语。


####2.1互斥器

互斥器是使用最多的同步原语。单独使用mutex的时候主要是为了使用共享数据。我的个人原则是：

使用RAII的手法创建销毁加锁解锁，这四个操作。避免因为忘记

只是使用非递归的mutex。

不手工调用Lock和unlock函数，一切交给栈上的Guard 对象的构造和析构函数负责。Guard的生命周期正好等于临界区。这样我们可以保证在同一个scope里，自动的加解锁。

在每次构造Guard对象的时候，思考一路上已经持有的锁,防止因加锁不同造成的死锁

次要原则是：

不使用非递归的mutex

1)加锁和解锁要在同一个线程，线程a不能去unlock线程b已经锁住的mutex

2)别忘了解锁

3)不重复解锁

4)必要的时候使用PTHREAD_MUTEX_ERRORCHECK来排错

####2.1.1只使用非递归的mutex

谈谈我坚持使用非递归的互斥器个人想法

mutex分为递归和非递归两种，这是posix的叫法，另外的名字是可重入和非可重入两种。这两种区别是同一个线程可以重复对可重入锁加锁，但是不能对非递归来加锁。

首选非递归的mutex，绝对不是为了性能，而是为了体现设计意图。递归和非递归其实性能差距不大，因为少了一个计数器，前者略微快一点，在 同一个线程里
多次使用非递归锁会导致死锁，这是一个优点，可以让我们及早发现不足。

毫无疑问递归锁用起来方便一些，不需要考虑在同一个线程里会自己把自己给锁死。

正是因为他很方便，递归锁可能会隐藏一些问题，你以为拿到一个锁可以修改对象了，没想到外层代码已经拿到了锁，正在修改同一个对象呢。

下面让我们看一下递归锁和非递归锁他们是如何使用的


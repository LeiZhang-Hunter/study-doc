#关于陈述书的一些笔记

####tcp网络编程本质论

基于非阻塞网络编程编写高性能的网络服务器是主流模式。把原来的主动recv接收数据，变成了主动accept去接受新的连接，主动send发送数据转换成注册
一个接收数据的回调，需要写数据的时候只管往里写，这有点像windows的消息机制，所以我们应该避免阻塞，否则会让服务失去响应。

TCP 网络编程最本质的是处理三个半事件:

1. 连接的建立,包括服务端接受(accept)新连接和客户端成功发起(connect)连接。TCP 连接一旦建立,客户端和服务端是平等的,可以各自收发数据。

2. 连接的断开,包括主动断开(close、shutdown)和被动断开(read(2) 返回 0)。

3.消息到达,文件描述符可读。这是最为重要的一个事件,对它的处理方式决定了网络编程的风格(阻塞还是非阻塞,如何处理分包,应用层的缓冲如何设计,等等)。

3.5 消息发送完毕,这算半个。对于低流量的服务,可以不必关心这个事件;另外,这里的“发送完毕”是指将数据写入操作系统的缓冲区,将由 TCP 协议栈负责数据的发送与重传,不代表对方已经收到数据。


陈硕muodu的168页方案6中有一个位置我认为说的不错：

方案 6
这是一个过渡方案,收到 Sudoku 请求之后,不在 Reactor 线程计算,
而是创建一个新线程去计算,以充分利用多核 CPU。这是非常初级的多线程应用,
因为它为每个请求(而不是每个连接)创建了一个新线程。这个开销可以用线程池
来避免,即方案 8。这个方案还有一个特点是 out-of-order,即同时创建多个线程去
计算同一个连接上收到的多个请求,那么算出结果的次序是不确定的,可能第 2 个
Sudoku 比较简单,比第 1 个先算出结果。这也是我们在一开始设计协议的时候使用
了 id 的原因,以便客户端区分 response 对应的是哪个 request。

用request_id来区分多个请求对应的多次response响应。

属于同一个 event loop 的连接之间没有事件优先级的差别。我
这么设计的原因是为了防止优先级反转。比方说一个服务程序有 10 个心跳连接,有10 个数据请求连接,都归属同一个 event loop,我们认为心跳连接有较高的优先级,
心跳连接上的事件应该优先处理。但是由于事件循环的特性,如果数据请求连接上
的数据先于心跳连接到达(早到 1ms),那么这个 event loop 就会调用相应的 event
handler 去处理数据请求,而在下一次 epoll_wait() 的时候再来处理心跳事件。因此
在同一个 event loop 中区分连接的优先级并不能达到预想的效果。我们应该用单独的
event loop 来管理心跳连接,这样就能避免数据连接上的事件阻塞了心跳事件,因为
它们分属不同的线程。
#11.2二进制程序的兼容性

比如你做了一个图形动态库的扩展,.so库，在公司内部使用非常好，然后在几十个部门之间推广开，
这时候公司突然升级了显示器，你的二进制程序不能很好试用，这时候你需要几十个部门重新编译，或者重新
覆盖原有的.so，这时候就要理解二进制程序的兼容性。

####11.2.1什么是二进制程序额兼容性？

用unix c 的ope 函数来举例子

linux c 

```c
open(const char* pathname, int flags);
```

flags 的三个值分别是 0 1 2，对应的宏是O_RDONLY, O_WRONLY, O_RDWR

linux 这三个 0 1 2，有一个缺点 0 | 1 != 2 ，为什么内核不换成 1 2 3 呢，如果修改了头文件
这样会造成一些旧的 二进制文件不能正常 运行，尽管已经更改了 头文件，但是就怕别人在二进制程序中写
死，所以说不能轻易动

所以说以 shared library 提供就需要考虑兼容性，不要轻易改动

####11.2.2有哪些情况会破坏库的ABI

C++ 编译器在ABI方面的主要工作：

1.函数参数的传递方式，比如x86-x64用寄存器来传递函数的前4个整数
2.虚函数调用方式，通常是vptr/vtbl机制，然后通过vtbl[offset]来调用
3.struct 和 class 的内存布局，通过偏移量来访问数据成员
4.名字管理
5.RTT1和异常处理的实现，本文不考虑

其实我认为上面的偏移量用c 来更容易 解释，我也想到了当年自己学习代码看到过类似的例子，用
c来似乎更能说明偏移量这件事

```c
#include <stdio.h>
struct demo2{
 
};
 
struct demo{
    int b;
    int c;
    int a;
};
 
typedef struct
{
    unsigned long dwFreq;
    unsigned char afclocked;
    unsigned char ucSndsys;
}ProgInfo;
#define offsetof(type, field)  (long)&(((type*)0)->field)
 
int main() {
    printf("%d\n", offsetof(ProgInfo, ucSndsys));
    printf("%ld\n",(size_t)(&((struct demo*)0)->a));
    return 0;
}
```

1. ( (TYPE *)0 ) 将零转型为TYPE类型指针;
2. ((TYPE *)0)->MEMBER 访问结构中的数据成员;
3. &( ( (TYPE *)0 )->MEMBER )取出数据成员的地址;
4.(size_t)(&(((TYPE*)0)->MEMBER))结果转换类型.巧妙之处在于将0转换成(TYPE*)，结构以内存空间首地址0作为起始地址，则成员地址自然为偏移地址；

```c
#include <stdio.h>
struct demo2{

};

struct demo{
    int b;
    int c;
    int a;
};

typedef struct
{
    unsigned long dwFreq;
    unsigned char afclocked;
    unsigned char ucSndsys;
}ProgInfo;
#define offsetof(type, field)  (long)&(((type*)0)->field)

int main() {
    printf("%ld\n",sizeof(int));
    printf("%ld\n",(size_t)&(((struct demo*)0)->a));
    return 0;
}
```

我们可以非常容易看出来c++ 获取数据成员主要是靠偏移量，因为通过这些demo，我们可以非常容易看出来
数据成员的偏移量

那么这里再说一下改动会造成ABI不兼容的例子

1.给函数增加默认参数，现有的可执行文件无法穿这个默认参数（我认为这个是没有问题的）
2.增加虚函数，会造成vtbl虚函数排列顺序的变化（不考虑在末尾添加）
3.增加模板类型参数，这回造成名称管理的变化
4.改变enum的值，末尾除外，会造成错位

给class添加数据成员也是不安全的，因为class的数据成员通过偏移量来访问，但是也有例外。

如果客户端里有new bar，那么肯定不安全，因为new 的字节数不能装下bar对象，如果库通过工厂模式
放回Bar*,或者直接返回shared_ptr,客户端不需要用到size of 那么也是安全的

如果客户端代码有Bar* pBar;pBar->memberA ,那么肯定是不安全的，如果通过成员函数来访问数据成员，那么一定是安全的。

如果Bar* pBar;pBar->memberA 变为了pBar::setMemberA 那么肯定不安全，因为函数已经
被内敛到了二进制文件中，如果用outline则是安全的


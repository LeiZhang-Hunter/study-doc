#13.1.6阻止拷贝

虽然大多数类定义拷贝构造函数和拷贝赋值运算符，但对某些类来说，这些操作没有合理的意义。在此情况下，定义类时候必须采用某种机制阻止拷贝和赋值。


####定义删除的函数
在新的标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为删除函数来阻止拷贝，删除函数是这样一种函数

```
class NoCopy{
public:
    NoCopy() = default;
    NoCopy(const NoCopy&) = delete;
    NoCopy &operator= (const NoCopy&) = delete;
    ~NoCopy() = default;
};
```

在函数后面加上=delete,我们通知编译器不希望有这些成员

与=default不同，=delete必须出现在函数第一次声明的时候，这个差异与这些声明的含义在逻辑上是吻合的。一个默认的成员只影响为这个成员而生成的代码，
一个默认的成员只影响为这个成员而生成的代码，因此=default知道编译器生成代码的时候才需要。另一方面编译器需要知道一个函数是删除的，以便禁止试图
用他的操作。


####析构函数不能是删除的成员

值得注意的是，我们不能删除析构函数。如果析构函数是被删除的，就此销毁此类型的对象了。对于一个删除了析构函数的类型，编译器将不允许定义这个类型
的变量或创建这个类的临时对象。而且，如果一个类有某个成员的类删除了析构函数，我们也不能定义这个类的变量或临时对象。但是不能释放这些对象

我们不能试着删除这个对象
```
class Foo{
public:
    Foo() = default;
    Foo(const Foo& foo) = default;
    Foo& operator=(const Foo& foo);
    ~Foo() = delete;
};



int main()
{
    Foo* foo = new Foo();
    return 0;
}
```

####合成的拷贝成员可能是删除的

如前所述，如果我们未定义拷贝控制成员，编译器会为我们定义合成版本。编译器会为其合成一个默认的拷贝构造函数。对某些类来说。对于一些类来说，编译器
将这些合成成员定义为删除的函数

1.如果类的某个成员的析构函数是删除的或者是不可访问的,则类的合成析构函数被定义为删除

2.如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除。如果类的某个成员的析构函数是删除的或者不可访问的，
则类合成的拷贝构造函数也被定义为删除的

3.如果类的某个成员的拷贝赋值运算符是删除的或者不可访问的，或是类有一个const或引用的成员，则类的合成拷贝赋值运算符被定义为删除的。

4.如果类的某个成员的析构函数是删除的或者是不可访问的，或是类有一个引用成员，他没有类内初始化器，或类是一个const成员
它没有类内初始化器且类型没有显示定义类内初始化构造函数，则该类的默认构造函数被定义为删除的。

这个本质是说的是如果一个类 或者其成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。

一个成员有删除的或不可访问的析构函数会导致合成默认和拷贝构造函数被定义为删除的

如果没有这些规则我们可能创建出无法销毁的对象

####private拷贝控制

在新的标准发布之前，类是将拷贝构造函数和拷贝运算符定义为private来阻止拷贝。

```
class noncopyable{
protected:
    noncopyable() = default;
    ~noncopyable() = default;

private:
    noncopyable(const noncopyable&) = delete;
    const noncopyable& operator=( const noncopyable& ) = delete;
};
```
#13.1.3析构函数

析构函数执行与构造函数相反的操作：构造函数初始化对象的非static数据成员，还可能做一些其他的工作；析构函数释放对象的使用资源，并销毁对象的非
static数据成员。

析构函数是类的一个成员函数，没有返回值也不接受参数

####析构函数用来完成什么工作呢？

如同构造函数有一个初始化部分和一个函数体，析构函数也有一个函数体和一个析构部分。在一个构造函数中，成员的初始化实在函数体执行之前初始化完成的，
且按照他们在类中的顺序进行初始化。在一个析构函数中，首先执行函数体，然后销毁成员。成员按照初始化的顺序逆序销毁。

在对象最后一次使用之后，析构函数的函数体可执行类设计者的任何收尾工作。通常析构函数释放对象在生存期分配的所有资源。

在一个析构函数，不存在类似构造函数中初始化列表的东西来控制成员如何销毁，析构部分是隐式的。成员销毁的时候发生什么完全依赖于成员的类型。销毁类
类型的成员需要执行类自己的析构函数，因此销毁内置类型成员不需要这么做

隐式销毁不会delete成员锁指向的对象

####什么时候会调用析构函数

无论何时一个对象被销毁，就会自动调用其析构函数：
1.变量在离开其作用域的时候被销毁掉

2.当一个对象被销毁的时候，其成员也会被销毁

3.容器被销毁的时候，其元素也会被销毁

4.对于动态分配的对象，当对指向它的指针应用delete

5.对于临时对象当他创建完整表达式结束的时候会被销毁掉

由于析构函数函数自动运行，我们的程序可以按照需要分配资源，无需担心何时释放这些资源。

通过一些demo我们来看一下何时释放这些资源

```
#include <iostream>
#include <vector>
#include <memory>

class Test{
    ~Test()
    {
        printf("delete Test\n");
    }
};

class Foo{
public:
    ~Foo()
    {
        test = new Test();
        printf("delete\n");
    }

private:
    Test* test;
};

int main()
{
    Foo* foo = new Foo;
    delete  foo;
    std::cout<<"end1"<<std::endl;

    {
        auto foo2 = std::make_shared<Foo>();
        Foo foo3;
        std::vector<Foo> vec;
        Foo* foo4 = new Foo();
        vec.push_back(*foo4);
    }
    std::cout<<"end2"<<std::endl;
    return 0;
}
```
程序变量会在离开作用域的时候被销毁，但是我们注意的是在堆上申请的成员变量却不会,在真正的c++程序中我还是比较推荐用智能指针的

####合成析构函数

当一个类未定义析构函数的时候，编译器会为他合成一个，合成析构函数用来阻止这个类型的对象被销毁，如果不是这种情况，合成析构函数的函数体就是空

下面的代码等价于Sales_data析构函数

```
class Foo{
public:
    ~Foo(){}

};
```

在空的析构函数执行完毕之后，成员会被自动销毁（逆序）。

认识到析构函数自身并不会直接销毁成员是十分重要的。成员是在析构函数体之后隐含的析构阶段被销毁的。在整个析构过程中，析构函数体是作为成员销毁步骤
之外的另一部分进行的。
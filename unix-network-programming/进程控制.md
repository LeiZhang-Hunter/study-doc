多个进程试图对共享数据进行处理，而且最后的运行结果取决于进程的运行顺序，我们就认为出现了竞争关系，为了避免竞争条件和轮询，在多个进程之间需要有某种形式的信号接收和发送方法，unix中可以使用信号机制，在10.16节说明，各种心酸的进程间通讯的ipc也可以使用。

exec 会替换进程的正文段 数据段 和 堆栈区

更改用户id和组id

进程需要访问当前程序不允许访问的资源的时候我们需要更改用户id和用户组id，这会降低恶意用户试图哄骗我们的程序的风险。

setuid:

1)如果进程具有超级用户特权，则setuid函数将实际用户id，有效用户id以及保存的设置用户id设置为uid

2）若进程没有超级用户特权，但是uid等于实际用户id和保存设置的用户id，则setuid只是有效用户id设置为uid，不更改实际用户id和保存设置的用户id

3）如果都不满足返回errno为EPERM

关于内核维护的3个用户id，还要注意下面这几个点：

1）只有超级用户才能更改实际用户id，实际用户id是用户在登录时候，由login程序设置的，而且不会改变它。因为login是一个超级用户进程，当他调用setuid时候，设置所有3个用户id。

2）仅当对程序文件设置了设置用户id的时候，exec函数才会设置子有效用户id，如果设置用户没有设置id，exec会保持现状。任何时候都可以设置有效用户id，任何时候都可以设置setuid，将有效用户id设置为实际永不id，自然的不能将有效用户id设置为任意的随机值。

3）保存的设置用户id是由exec复制有效用户id而得到的。如果设置了文件的设置用户id位，则在exec根据文件的用户id设置了进程的有效用户id以后，这个副本会被保存起来。

1。setreuid和setregid

其功能是交换实际用户id和有效用户id的值。

2.seteuid个setegid
是设计实际有效的用户id和实际有效的组id

3.组id

附属组id不受setgid、setregid和setegid函数的影响。


1）程序文件是由root用户拥有的，并且其设置用户id位已设置，当我们运行程序的时候会得到下面的结果：

实际用户id=我们的用户id（为改变）
有效用户id=root
保存设置的用户id=root


2）at程序做的第一件事情就是降低特权，以用户特权运行。他调用setuid把有效用户id设置为实际用户id。

实际用户id=我们的用户id
有效用户id=我们的用户id
保存设置用户id=root

3）at程序以我们的用户特权运行，知道它需要访问那些命令即将运行，这些命令需要何时运行的配置文件的时候，at程序的特权都需要改变。这些进程由用户运行命令的守护进程持有。

实际用户id=我们的用户id
有效用户id=root
岙村的用户id=root


8.1.2 解释器文件

所有现今的unix系统都支持解释器文件。这种文件是文本文件

	#！ /bin/sh

!和空格是可选的

被执行的解释器文件的内容只有一行，arg[0]是解释器的pathname，arg[1]是解释器的可选参数，

1.有些程序是用某种脚本语言写的，但是这不能隐藏他是一个解释器文件的事实。



最长见的解释器文件是/bin/sh

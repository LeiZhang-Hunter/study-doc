#共享内存

共享内存区是可用ipc形式最快的.一旦这样的内存区映射到共享他的进程地址空间，这些进程间的数据的传递就不再涉及内核。然而往该共享内存区存放信息或从中取走信息的进程通常需要某种形式的同步。我们在第三部分已经讨论过了同步：互斥锁以及条件变量、读写锁、记录锁和信号量。

这里说的不再涉及内核的含义是：进程不再通过执行任何进入内核的系统调用来彼此传递数据。显然，内核必须建立允许各个津成共享该内存区域的映射关系，然后一直管理内存区。

考虑用来传递各种类型的消息的一个示例客户-服务器文件复制程序中涉及的通常步骤。

服务器从输入文件读。该文件的数据由内核读入自己的内存空间，然后从内核复制到服务器进程。

服务器往往通过一个管道、FIFO或消息队列以一条消息的形式写入这些数据。这些IPC形式通常需要把这些数据从进程复制到内核

客户从该ipc管道读出这些数据通常需要把数据从内核再复制到进程

最后将这些数据由write的第二个参数制定的客户缓冲区输出到文件。

这些ipc形式的问题在于，两个进程要交换信息，这些信息由内核传递。

通过让两个或多个进程共享一个内存区域，共享内存区这种ipc形式提供了绕过上述问题的方法，这些进程必须协调或同步堆这个共享内存区域使用

客户-服务器例子现在涉及步骤如下。

1）服务器使用一个信号量取得访问某个共享内存对象的权利。

2）服务器将数据从输入文件读入到共享内存对象。read函数的第二个参数指定的数据缓冲区地址指向这个共享内存对象。

3）服务器读入完毕，使用一个信号量通知客户。

4）客户将这些数据从这个共享内存区对象写出到输出文件中。

###12.2 mmap、munmap和msync函数

mmap函数把一个文件或一个Posix共享内存区对象映射到调用进程的地址空间。使用这个函数有三个目的。

1）使用普通文件来提供内存映射IO
2)使用特殊文件来提供匿名内存映射
3)使用shm_open来提供无亲缘关系进程间的posix共享内存

	#include <sys/mman.h>
	
	void *mmap(void *addr,size_t len,int prot,int flags,int fd,off_t offset);
	
其中addr可以指定描述符fd应被映射到的进程内空间的起始地址。他通常被指定为一个空的指针，这样告诉内核自己区选择起始地址。无论那种情况下，这个函数的返回值都是描述符fd所映射到内存区的起始地址。

len是映射到调用进程地址空间的字节数，它从被映射文件开头其第offset字节出开始算。offset通常被设置为0.
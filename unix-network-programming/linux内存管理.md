#第八章内存管理

对于一个进程来说,内存是最基本也是最重要的资源。这一章的内容包括：存储器分配、内存操控和内存释放以及内存释放

了解如何锁定内存，从而避免了你再程序中等待内核从交换区换页。

8.1进程的地址空间

和所有的现代操作系统一样，linux将物理内存虚拟化。进程并不能直接在物理内存上寻址，而是由linux内核为每个进程维护一个特殊的虚拟空间。这个空间地址是线性的，从0开始，到某个最大值。

8.1.1页和页面调度

虚拟空间由许多页组成。系统的体系结构以及机型决定了也的大小（页的大小是固定的），典型的也的大小包括4k(32)位系统以及8k(64位系统).每一个页面只有无效和有效两种状态，一种是有效页面和一个物理页或者一些二级存储介质

在这里我思考为什么32位系统一页占用4k 而 64位系统占用的是8k？



例如一个交换分区或者一个在硬盘上的文件。一个无效页面没有关联，代表它没有被分配使用。对于无效页面的访问会引发一个段错误。地址空间不需要是连续的。虽然是线性编址，但实际上中间有很多未编址的小区域。

一个进程不能访问一个处在二级存储中的页，除非这个页和物理内存中的页相互关联。如果一个进程尝试访问这样的页面会发生一个页错误。然后内核会透明的从二级存储换入需要的页面。因为一般来说虚拟存储器总是比物理内存大，所以内核也需要经常的把页面从物理内存换出到二级存储，从而为将要转入的页面腾出空间。内核总是将未来不可能使用的页换出来优化性能。

####8.1.1.1共享和写时复制
虚存中的多个页面，甚至是属于不通进程的虚拟地址空间，也有可能被反映射到同一个物理页面。
这样允许不通的虚拟地址空间共享物理内存上的数据。共享数据可能是只读的，或者是可读可写的。

当一个进程试图写某个共享的可写页的时候，可能发生以下两种情况。最简单的是内核允许这个操作，在这种情形下所有共享这个页的进程都将看到这次写操作的结果。通常大量进程对同一个页面进行读写的时候需要某种成都上的合作和同步操作机制。

这个我感觉有点像共享内存

另一种情况是MMU会截取这次写操作并产生一个异常；作为回应，内核会透明的创造一份这个页的拷贝以供给这个进程进行写操作，这就叫做写时复制。允许读取共享的数据可以节省空间。当一个进程试图写这个共享页面的时候，可以立刻获得一个这个页的拷贝，是的进程内核工作起来像每个进程都始终有自己的私有拷贝。写时拷贝是以页为单位进行的，因此一个大文件可以有效的被众多进程共享。而每个进程只有在对共享页写时才会获得一份新的拷贝。


####8.1.2存储器区域

内核将具有某些相同特征的页组织成块，例如读写权限。这些块叫做存储器区域，段(segments),或者映射，下面是一些在每个进程都可以见到的存储器区域：


文本段包含着一个进程的代码，字符串，常量和一些只读数据。

堆栈段包含一个进程的执行栈，随着栈的深度动态的伸长或者收缩。执行栈中包含了程序的局部变量和函数的返回值。

数据段 又叫堆，包含这一个进程的动态存储空间。这个端是科协的，而且它的大小是可变化的。这部分空间往往是由malloc分配的。

BSS段，包含了没有被初始化的全局变量。这些变量根据不通的c标准都有特殊的值。

linux从两个方面优化这些变量。首先，因为附加段是用来存放没有被初始化的数据的，所以连接器实际上并不会将特殊值存储在对象文件中。这样可以减少二进制文件的大小。其次，当这个段被加载到内存时候，内核只是需要简单的根据写时复制的原则将他们映射到一个全是0的页上，这样十分有效的设置了这些变量的初始值。

大多数地址空间中包含了很多映射文件，比如可执行文件自己，c或者是其他的可链接库和数据文件。可以看看/proc/self/maps, 或者pmap程序的输出，我们可以看到一个进程里面有很多映像文件。


####8.2动态内存分配

内存同样可以通过自动变量和静态变量获得，但是所有内存管理系统的基础都是动态的内存分配，使用以及动态的返回。动态内存是在进程运行时候才分配的，而不是在编译的时候就分配好的，而分配的大小只有在分配的时候才知道的。作为一个程序员在程序员你不会知道程序占用了多少内存，或者你使用这块内存的时间不定，则需要使用动态内存

例如c不会提供在动态内存中获取结构体struct priate_ship的机制，而是提供一种机制在动态内存中分配一个足够大的空间来保存priate_ship的机制，而是提供了一种机制在动态内存中分配一个足够大的空间来保护priate_ship。程序员通过一个指针来对这块内存进行操作，这个指针就是struct priate_ship*。


malloc 失败的时候会返回NULL，并把errno设置为ENOMEN。

######8.2.1数组分配

当分配数据内存本身大小可变，动态分配内存更加复杂。为数组动态分配内存就是一个更好的例子

```
	#include <stdlib.h>
	void *calloc(size_t nr,size_t size);
```

calloc与malloc的区别，calloc分配的区域全部用0进行了初始化，因此y中的50个元素都被赋值为0，但是x数组里面的元素却是未定义的。注意calloc会比memset快

######8.2.2调整已经分配的内存大小

```
	void *realloc(void *ptr,size_t size);
```

成功调用realloc将ptr指向的内存区域大小变为size字节。他返回了一个指向新空间的指针，当试图扩大内存的时候返回的指针可能不在是ptr。如果realloc不能在已经由的空间上增加到size大小，那么就会额外申请一块size大小的空间，并且将原本内容拷贝到新的空间。因为有潜在的拷贝操作所以realloc的操作是比较耗时的。

如果ptr是NULL，结果就会跟malloc一样。如果ptr是非NULL的，那么他必须是之前调用的malloc，calloc或realloc之一的返回值。当失效的
c不会提供支持动态内存的变量。

######8.2.3动态内存的释放free
free掉对应地址之后就可以

######8.2.4对齐

数据对齐是指数据地址和硬件确定的内存块之间的关系。一个变量地址是它大小的倍数时，就叫做自然对其，如果一个变量长32位是4的倍数就是自然对其。如果一个类型大小是2n个直接，那么他的地址中，至少低n位是0.对齐规则是根据硬件制定的。在一些系统中载入一个没对齐的数据会发生错误。在可移植的代码中对齐问题一定要注意！！！

32位系统是8位对齐，64位系统是16字节对齐。

posix提供了一个叫做posix_memalign的函数：

```
	#include <stdlib.h>
	void* valloc(size_t size);
	posix_memalign(void **memptr,size_t alignment,size_t size);
```

调用posix_memalign成功时候会返回size字节的动态内存，并保证是按照alignment进行对其的，参数alignment必须是2的幂次方，以及void指针大小的倍数。返回的内存块的地址保存在memptr里，函数返回0

调用失败返回下面这些错误码

EINVAL 参数不是2的幂次方，或者不是void指针的倍数

ENOMEM没有足够的内存去满足函数的申请

函数valloc的功能和malloc一模一样，但是返回的地址是页面对齐的。回顾一下第四章，页面的大小很容易通过getpagesize得到。

相似地，函数memealign是以boundary字节对齐的，而boundary必须是2的幂。在这个例子中，两个函数都返回一块足够大的内存去存放一个ship结构，并且地址都是在一个页面的边界上,这些函数申请的api都可以通过free来释放。

8.2.4.2 其他对齐问题

除了标准类型的对其和内存分配，对齐问题可以进行扩展。比如说，复杂的数据类型的对齐问题将会比标准类型的更加复杂。另外，在不同类型的指针进行赋值以及强制类型转换的时候，对齐的问题更加重要。

非标准类型。非标准和复杂的数据类型的对齐比简单的自然的对齐有更加多的要求：

一个结构的对其要求和它的成员中最大的那个类型是一样的。例如一个结构中最大的是以4个字节对其的32bit整形，那么这个结构至少以4个字节对齐。

下面是四条有用的规则：

一个结构的对其要求和它的成员中最大的类型是一样的。例如，一个结构中最大的是以4字节对齐的32bit的整形，那么这个结构至少要以4个字节对齐。

结构体引入了对填充的需求，以此来保证每一个成员都复合各自的对齐要求。所以如果一个char后面跟着一个int，编译器会自动插入3个字节来保证int以4个字节对齐。程序员要注意结构体中成员变量的顺序，来减少填充锁导致的空间浪费。

```
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int bss_end;

typedef struct _demoOne{
    char one;
    char two;
    int three;
}demoOne;

int main()
{
    int a;
    printf("%ld\n",sizeof(demoOne));
    return 0;
}
```

上面这个占用了8个字节，并不是12个字节因为是

4+4 前面两个字节合并了共占用了4个字节

```
typedef struct _demoOne{
    char one;
    int three;
    char two;
}demoOne;
```

这样就会导致占用12个字节，所以我们在使用结构体的时候一定要注意变量顺序避免字节浪费！！！

一个联合的对齐和联合里面最大的类型一致。

一个数组的对齐和数组里的元素类型一致。所以对数组里面的元素做对齐以外，没有其他的对齐要求	。

使用指针。因为编译器透明的处理了绝大多数的对齐问题，所以要找到潜在的错误的时候比较困难，然而以这样的错误并不少见，特别是在处理指针和强转的时候。

假设一个指针从一个较少字节对齐类型强转为一个较多的字节对齐类型，通过这样的指针来访问的时候，会导致处理器不能对较多字节类型的数据正确对齐、例如下面的代码片段，c到badnews的强转使得程序将c转为unsigned long来读：

```
char greeting[] = ”Ahoy Matey”;
char *c = greeting[1];
unsigned long badnews = *(unsigned long *) c;
```

一个unsigned long 可能以4或8个字节对齐；而c当然只以1字节为边界对齐。因此当c被强转之后再进行读取将会导致对齐错误。

####8.3数据段的管理

unix系统在历史上提供过直接管理数据的接口。然而因为malloc和其它的方法更强大也容易使用，大多的程序不会使用这些接口。看一下这些接口：

```
#include <unistd.h>
int brk(void* end);
void* sbrk(int ptr_t increment);
```

这些函数继承了一些老版本的unix系统中函数的名字，同事堆和栈还在同一个段中。堆中动态存储器的分配由数据段的底部向上生长；栈从数据段的顶部向下生长。栈和堆的分界线叫做中断或中断点。在现代系统中，数据段存在与自己的内存映射中，我们仍用中断点来标记映射结束地址。

调用brk会设置中断点的地址为end。在成功的时候返回0，失败的时候返回-1，并设置errno为ENOMEM

调用sbrk将数据段末端增加increment字节，increment可正可负。sbrk返回修改后的断点。所以increment为0的时候得到的是现在的断点地址：

sbrk获取堆向上之后的位置 地址 
sbrk 0 可以获取break的地址

brk 是把break的地址设置为某个地址

```
#include <unistd.h>
int main()
{
    void* heap_break = sbrk(2);
    brk(heap_break);
}

```
AVL树

树是带有平衡条件的二叉树.这个平衡条件必须要容易保持，而且必须保持树的深度，而且他的深度是O(logN).最简单的想法就是要求左右子树具有相同的高度。

另一个平衡的条件是要求每个节点都要有相同高度的左子树和右子树。如果空子树的高度定义为-1，那么它只是具有2的k次方-1的节点的理想的平衡树，那么只有据欧2的k次方减一的节点的理想的平衡树才会满足这个条件，所以他比较严格很难保持平衡条件

除去可能的插入外，所有数的操作都是logN执行、因为当进行插入操作的时候，我们需要更新通项根节点路径上的那些节点所有的平衡信息，而插入操作隐含这困难的原因在于，插入一个节点可能会破坏AVO树的特性。如果在这种情况下。那么就要在恢复完成插入后才能进一步进行插入。我们称这个为旋转。

在插入以后，只有那些从插入点到根节点路径上的节点的平衡可能被改变，因为只有这些节点的子树发生变化。当我们沿着这条路径上并查找更新平衡信息的时候，我们可以找到一个节点，他的新平衡破坏了AVL条件。我们将指出如何在第一个这样的节点重新平衡这棵树，并证明这一重新平衡保证整个树满足AVL的特性。

让我们把必须重新平衡的节点叫做@。由于任意节点最多有两个儿子，因此高度不平衡的时候，@点的两颗字数的高度差为2.

这种不平衡的条件可能出现在下面这四种情形

1.对@的左儿子的左子树进行一次插入

2.对@的左儿子的右子树进行一次插入

3.对@的右儿子的左子树进行一次插入

4.对@的右儿子的右子树进行一次插入

情形1和4是关于@点的镜像对称，而2和3是关于@点的镜像对称，因此理论上只有两种情况，但是从编程角度上来说是4种情况

第一种情况是插入发生在外边的情况，这种情况通过对树的一次单旋转而完成调整。第二种情况是插入发生在内部的清晰，通过稍微复杂一些的双旋转来处理。
#cPrimer第十章节数组和指针

10.1数组

前面介绍过，数组由数据类型相同的一系列元素组成，需要使用数组的时候，通过声明数组告诉编译器数组中包含多少元素以及元素的类型。编译器根据这些信息正确的创建数组。普通变量可以使用的类型数组都可以使用

	int main(void)
	{
		float candy[365];
		char code[12];
		int states[50];
	}
	
方括号[]表面candy、code和states都是数组，方括号中的数字表面数组元素的个数,所以candy[0]标示candy数组的第一个元素，candy[364]标识第364个元素。也就是最后一个元素.

10.1.1初始化数组

数组通常被用来存储所需要的数据，数组在一开始就初始化完成比较好，下面介绍数组初始化方法

	int main(void)
	{
		int powers[8] = {1,2,4,6,8,16,32,64};
	}
	
如上面所展示的，用逗号分割值的列表来初始化数组，各个值之间用逗号分开。在逗号和值之间可以使用空格。根据上面的初始化，把1赋值给powers[0]，以此来类推，ANSI的编译器会不识别，在前面加入static可以解决这个问题.

我们需要注意使用const来声明的数组

有时候需要把数组设置为只读。这样程序只能从数组中区检索值，但是不能写入值到数组，要创建只读数组，应用const声明和初始化数组。

如果数组初始化失败了怎么办？

	#define SIZE 4

	int main()
	{
	    int no_data[SIZE];

	    int i;

	    printf("%2s%14s\n","i","no_data[i]");

	    for(i=0;i<SIZE;i++)
	    {
		printf("%2d%14d\n",i,no_data[i]);
	    }
	    return  0;
	}
	
运行结果:
	
	 i    no_data[i]
	 0     868145952
	 1         21965
	 2     868145088
	 3         21965
	 
使用数组之前必须要初始化他们，和普通变量类似，在使用他们之前必须初始化.编译器使用的值都是内存相应位置的现有值，因此读者运行改程序的值会和例子不一样

注意：存储类别警告

	数组和其他变量类似，可以把数组创建成不同的存储类别。第12个章节介绍存储类别的相关内容，现在就需要记住：本章描述的数组属于自动存储类别，意思是这些数组在函数内部声明，且声明时候未使用static关键字。

	这里提到存储类型是有原因的，因为不通的存储类有不同的属性，所以不能把本章的内容推广到其他的存储类别，对于一些其他的存储类别的变量和数组，如果在声明的时候没有被初始化，编译器会自动把他设置为0.
	
如果初始化列表的项数多于数组元素个数，编译器会直接报错，不过我们也可以省略方括号里面的数字，让编译器自己去匹配

####10.1.2指定初始化器(C 99)

C99新增加了一个特性：制定初始化器。利用这个特性可以初始化制定的数组元素。例如，只初始化数组中的最后一个元素，对于传统的c语法，必须初始化最后一个元素之前的所有袁术才能初始化他

如：传统语法

	int arr[6] = {0,0,0,0,0,212};
	
而C99规定，可以再初始化列表中使用带方括号的小标致命待初始化的元素:

	int arr[6] = {[5] = 212}; //把arr[5] 初始化为212
	
例子：

	#define MONTHS 12
	int main()
	{
	    int days[MONTHS] = {31,28,[4] = 31,30,31,[1] = 29};
	    int i;

	    for(i=0;i<MONTHS;i++)
	    {
		printf("%2d %d\n",i+1,days[i]);
	    }
	    return  0;
	}
	

	 1 31
	 2 29
	 3 0
	 4 0
	 5 31
	 6 30
	 7 31
	 8 0
	 9 0
	10 0
	11 0
	12 0

以上输出提示了指定初始化器的两个重要的特性.

第一，如果制定初始化器后面有更加多的值，如该例子中的初始化列表的片段：[4] = 31,30,31，那么后面这些值将被用于初始化制定后面的元素.也就是说，在days[4]被初始化为31后，days[5]和days[6]将被初始化为30和31.

第二，如果再次初始化指定的元素，那么最后的初始化将会被取代之前的初始化。例如程序清单10.5中，列表开始把days[1]初始化为28，但是days[1]又被【1】初始化为29.

如果没有被指定长度会怎么样？

	int stuff[] = {1,[6] = 23};
	int staff[] = {1,[6] = 4 , 9 ,10};
	
会发生什么呢？

编译器会把数组大小设置为足够装的下初始化的值，所以stuff数组是有7个元素的，编号为0~6


####10.1.3 给数组元素赋值

声明数组后，可以借助数组下标，给元素赋值.例如，下面的程序段给数组元素的所有元素赋值.

	#include <stdio.h>

	#define SIZE 50
	
	int main(void)
	{
		int counter,events[SIZE];
		
		for(counter = 0;counter<SIZE;counter++)
			events[counter] = 2*counter;
	}
	
注意这一段代码中使用循环给数组元素依次赋值，c不允许把数组作为一个单元赋值给另一个数组，初始化以外也不允许使用花括号列表的形式赋值。下面的代码给出了错误的赋值形式.

	#define SIZE 5
	int main(void)
	{
		int oxen[SIZE] = {5,3,2,8};
		
		int yaks[SIZE];
		
		yaks = oxen; //这么做是不会被允许的
		yaks[SIZE] = oxen[SIZE];//数组下表越界了
		yaks[SIZE] = {5,3,2,8};//这么做并不会起什么作用
	}
	
	
oxen数组的最后一个元素是oxen[SIZE-1],所以oxen[SIZE] 和 yaks[SIZE]都超出了两个数组的末尾.

####10.1.4数组边界

在使用数组的时候，要防止数组下标超出边界。也就是说，必须确保下标是有效的值。例如下面声明：

	int doofi[20];
	
那么在使用数组的时候，要确保程序中使用下标在0~19的范围内，因为编译器不会检查这种错误，但是一些编译器会发出警告然后继续编译程序.

	#include <stdio.h>
	#define SIZE 4
	int main(void)
	{
	    int value1 = 44;
	    int arr[SIZE];
	    int value2 = 88;
	    int i;

	    printf("value1 = %d,valuw2=%d\n",value1,value2);

	    for(i = -1;i<7;i++)
		printf("%2d %d\n",i,arr[i]);
	}
	
	value1 = 44,valuw2=88
	-1 88
	 0 -1513014480
	 1 21899
	 2 -1513015360
	 3 21899
	 4 151258960
	 5 32767
	 6 -1329329920

	Process finished with exit code 0
	
注意编译器似乎把value2存储在数组的前一个位置，把value1 存放在数组的后一个位置.在上面的程序之中value2 与 arr[-1]对应，value1与arr[4]对应.使用越界的数组下标会导致程序改变其他变量的值.不通编译器会导致运行结果不一样，有一些会直接终止.。因此为了安全，编译器必须在运行的时候添加额外的代码检查数组每一个下标的值，这会降低代码运行速度。c相信程序员可以写正确代码，这样运行速度快。但是并不是每一个人都能做到，所以会产生越界问题

要记住数组是从0开始的。最好是在声明数组时候使用符号常量来标示数组的大小.


####10.2.1初始化一个二维数组

省略 比较简单

####10.3指针和数组

第九章介绍过，指针提供一种以符号形式使用地址的方法.因为计算机的硬件指令十分的依赖地址，指针在某种成都上把程序员想要传达的指令以更接近机器的表达方式.因此使用指针会让程序更有效率，指针能有效的处理数组。我们很快就可以学到，数组表示法其实是在变相的使用指针.

我们举一个变相使用指针的例子：数组名是数组首元素的地址。也就是说flizny是一个数组。

	flizny == &flizny[0];//数组名就是这个数组元素的地址
	
flizny和&flizny[0]都标示数组首元素的内存地址（&是首地址运算符）.两者都是常量，在程序的运行过程中，不会改变。但是，可以吧他们赋值给指针变量，然后修改指针变量的值.注意指针加一个数的时候，他的值会发生什么变化？（转换说明%p通常以十六进制）

pnt_add.c 程序:

	#define SIZE 4

	int main(void)
	{
	    short dates[SIZE];

	    short *pti;

	    short index;

	    double bills[SIZE];

	    double *ptf;

	    pti = dates;//把数组赋值给指针

	    ptf = bills;

	    printf("%23s %15s\n","short","double");

	    for(index = 0;index < SIZE;index++)
		printf("pointers + %d : %10p %10p \n",index,pti+index,ptf+index);
	    return 0;
	}
	
下面这个例子的输出的值:

		         	 short          double
	pointers + 0 : 0x7ffc34751838 0x7ffc34751840 
	pointers + 1 : 0x7ffc3475183a 0x7ffc34751848 
	pointers + 2 : 0x7ffc3475183c 0x7ffc34751850 
	pointers + 3 : 0x7ffc3475183e 0x7ffc34751858 

	Process finished with exit code 0
	
在我们的操作系统中，地址按字节编码，short类型占2个字节，double类型占8个字节.在c中加1是增加一个存储单元，而不是下一个字节的地址，这就是我们为什么要声明指针对象类型的原因之1.只知道地址不够，因为计算机要知道多少存储类型.

指针的值是它所指向对象的地址.地址表示方式依赖计算机硬件.
在指针前面使用*就可以获取到指针的值了
指针+1，指针值递增增长它指向类型的宽度.

以上说明了指针和数组的关系十分密切，ar[n]的意思就是*(ar+n)

同时也要注意：

*(dates+2) //是dates的第三个元素

*dates+2//是dates的值+2

####10.4函数数组和指针
	

	
